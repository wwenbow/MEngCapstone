%        File: Intro.tex
%     Created: Sun Mar 02 03:00 PM 2014 P
% Last Change: Sun Mar 02 03:00 PM 2014 P
%
\documentclass{article}
\usepackage{fullpage}
\usepackage{biblatex}
\usepackage{hyperref}
\usepackage{amsmath}
\addbibresource{CapstoneCitations.bib}

\begin{document}

\section{Materials and Methods}
\subsection{Materials}
\paragraph{PIC32MX795F512L:} A 32 bit micro-controller for performing the control
algorithms of the robot. The PIC32MX795F512L comes from SparkFun electronics as
part of the UBW32 board, which comes preloaded with a bootloader for programming
the board. The PIC32MX795F512L is programmed in C/C++. To make the device easier
to use, we loaded an avrdude bootloader onto the device to use the MPIDE
software. The MPIDE framework allows us to use Arduino libraries on the
PIC32MX795F512L which helps to accelerate development of basic I/O software for
the board\cite{pic32data}.

\paragraph{PICKIT3:} A hardware programmer for the PIC32MX795F512L
microprocessor. The pickit3 and program and debug the PIC32 micro-controller.
Used to download code onto the UBW32. Useful for installing new bootloaders onto
the UBW32 and for restoring broken firmware\cite{pickitdata}.

\paragraph{MPU6050:} A gyro and accelerometer for obtaining information about the
kinematics of the arm and the leg. Uses I2C connection to the PIC32MX795F512L
for communication\cite{mpu6050data}.

\paragraph{HSR-5498SG:} Servos from Hitec. Utilized to control arm and leg
joints.  The servos require 6-7 Volts. Each servo requires approximately 200mA.
The actuation of the arm is accomplished by mini-motors\cite{sscdata}.

\paragraph{SSC-32:} Servo controller from Lynx motion. The on-board controller
is an Atmega168-20PU. The SSC-32 is controlled using serial signals from another
microprocessor or the PC. The control signal is a simple byte stream. The
controller can specify pin number, servo position, rotation speed, and rotation
time. It can power 32 servos simultaneously\cite{servodata}.

\subsection{Methods}
\subsubsection{Preliminary Setup}
\paragraph{} To program the PIC32MX795F512L, we used the Multi-Platform
Integrated Development Environment(MPIDE) environment from chipKIT. To use MPIDE
with the program, we had to program the PIC32 with the avrdude bootloader found
here: \url{https://github.com/chipKIT32/PIC32-avrdude-bootloader}. Using the
pickit3, we loaded the new bootloader onto the UBW32 and was able to use MPIDE
to program the board.

\paragraph{} While the other team members were constructing the mechanical
components of the legs and arms, I proceeded to set up the basic components of
the controller. We set up the MPU6050 using the PIC32 I2C libraries in MPIDE and
proceeded to do basic calibration and testing. Then we set up the servos using
the SSC-32 controller and the PIC32. Using the PIC32's Universal Asynchronous
Receiver/Transmitter(UART) we set up a serial communication channel between the
PIC32 and the SSC-32.  

\subsubsection{Servo Setup} 
\paragraph{} To control the servos we would send a string through the PIC32 UART
channel to the SSC-32. The string encoded the pin number, desired position and
desired rotation time for one of the 32 servo channels on the
SSC-32\cite{sscdata}. There were six servos on each leg of the robot and four on
each arm. On the legs, there were two servos per ankle, one on the knee, and
three on the hip. In total that gives us six degrees of freedom.  The arms were
assembled similarly, with one servo on the elbow and three in the shoulder. The
servos were powered through the SSC-32 board. Each servo requires around 200mA
of current and 6-7V of voltage\cite{servodata}. We used a 6V power supply to
power the servos channels on the SSC-32, and a 9V battery to power the logic
circuit of the servos. The PIC32 was powered through a USB connection to the PC.

\subsubsection{Walking Algorithm Implementation} 
\paragraph{} The walking algorithms were designed by Zhu Ziqi, a fellow team
member. He designed and simulated the algorithms in MATALB and SIMULINK and I
implemented the algorithms in C++ on the PIC32MX795F512L. The algorithms are
based on Central Pattern Generators, a part of biological neural networks which
generate rhythmic control signal for human motion\cite{cpggeneral}. The servos
are controlled using sine waves of varying shapes to generate patterns for
walking. Ziqi performed simulations to to select the best parameters for the
sine waves. For our preliminary walking algorithms we only considered the knee
and hip joints, keeping the other joints rigid. The SSC-32 position control
signal requires a integer ranged from 500 to 2500, corresponding to
$180^{\circ}$ of motion\cite{sscdata}. Due to the mechanical construction of the
arm and leg joints, which mimicked human structure, most joint servos were
limited to a range between 1250 and 2500. The output from the sine waves would
be converted to a range in the SSC-32's output and then sent to the servos. 
\begin{align}
    sine_{knee\_joint}=sin(eqn\_pending) \label{sineknee}\\
    sine_{hip\_joint}=sin(eqn\_pending) \label{sinehip}
\end{align}
Equations \ref{sineknee} and \ref{sinehip} show the equations for calculating
the position of each servo as a function of time. The positions of the legs are
calculated by the PIC32 and sent to the SSC-32.

\subsubsection{Leg Balance Algorithm}
%TODO: Get Yanchen's algorithms
\paragraph{} Waiting for team member to finish simulations of control
algorithms. Likely will use the MPU6050 to get the information about balance.

\subsubsection{Arm Control Algorithm}
\paragraph{} The arms are controlled using a Fuzzy Inference System. A fuzzy
inference system comprises of a fuzzifier, inference system, and defuzzifier.
The fuzzyfier takes inputs and out converts them to fuzzy values of a set of
fuzzy variables for the inference system. In this case the input is the desired
position of the arm in 3D space. The inference system is a set of if else
statements that determine a desired output from the fuzzy values. The
defuzzifier then converts this output to a real output to our
servos\cite{fuzzy2011}. To design this system we will take two approaches, one
through simulation and one through machine learning. I will work on the Machine
Learning approach. MATLAB has neural network algorithms that will generate fuzzy
inference systems. To do this we will generate

\printbibliography

\end{document}
